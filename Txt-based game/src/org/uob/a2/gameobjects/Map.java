package org.uob.a2.gameobjects;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.io.*;
import java.nio.file.*;

import org.uob.a2.utils.*;

/**
 * Represents the game map, which consists of a collection of rooms and the current room the player is in.
 * 
 * <p>
 * The map allows for navigation between rooms, adding new rooms, and managing the current room context.
 * </p>
 */
public class Map {
    private ArrayList<Room> rooms;
    // maps the roomId ==> index within rooms
    private HashMap<String, Integer> mapping;

    private char[][] mapArr;
    private HashMap<String, Integer> coordMappingX;
    private HashMap<String, Integer> coordMappingY;
    
    private int currentRoomIdx;
    public Map(){
        this.rooms = new ArrayList<Room>();
        this.mapping = new HashMap<String, Integer>();
        this.currentRoomIdx = -1; // invalid as index >= 0
        this.coordMappingX = new HashMap<String, Integer>();
        this.coordMappingY = new HashMap<String, Integer>();
    }

    public void addRoom(Room room){
        // assigns mapping from room Id to index and adds to arrayList
        mapping.put(room.getId(), rooms.size());
        rooms.add(room);
    }

    public Room getCurrentRoom(){
        if (currentRoomIdx != -1){
            return rooms.get(currentRoomIdx);
        }
        return null;
    }

    public void setCurrentRoom(String roomId){
        int idx;
        if ((idx = mapping.getOrDefault(roomId, -1)) != -1){
            // changes display map so ensures display map has been generated by assigning room symbol to room
            // moving from and '@' to the next room
            if (currentRoomIdx != -1 && mapArr != null){
                Room oldCurrentRoom = rooms.get(currentRoomIdx);
                mapArr[coordMappingY.get(oldCurrentRoom.getId())][coordMappingX.get(oldCurrentRoom.getId())] = oldCurrentRoom.getDispSymbol();
                
                String newCurrentRoomId = rooms.get(idx).getId();
                mapArr[coordMappingY.get(newCurrentRoomId)][coordMappingX.get(newCurrentRoomId)] = '@';
            }

            // sets new current room
            currentRoomIdx = idx;            
        } else {
            System.out.println("You can not enter this room ");
        }
    }

    public void generateDispMap(){
        int lowestNumX = 0, highestNumX = 0;
        int lowestNumY = 0, highestNumY = 0;
        String roomId, nextRoomId;
        
        coordMappingX = new HashMap<String, Integer>();
        coordMappingY = new HashMap<String, Integer>();
        HashSet<String> visited = new HashSet<String>();
        ArrayList<String> queue = new ArrayList<String>();
        ArrayList<Exit> exits;
        
        if (currentRoomIdx != -1){
            roomId = rooms.get(currentRoomIdx).getId();
            queue.add(roomId);

            coordMappingX.put(roomId, 0);
            coordMappingY.put(roomId, 0);
            visited.add(roomId);
            int x, y, incY, incX;

            // performs BFS using exit names of 'north', 'east', 'south', 'west' to increment idx
            while (queue.size() != 0){
                roomId = queue.get(0);
                queue.remove(roomId);

                // gets position of current room
                x = coordMappingX.get(roomId);
                y = coordMappingY.get(roomId);
                
                exits = rooms.get(mapping.get(roomId)).getExits();
                // for each exit, update increments for next room
                for (Exit exit: exits){
                    incY = 0;
                    incX = 0;
                    if (exit.getName().equals("north")){
                        incY = -1;                     
                    } else if (exit.getName().equals("south")){
                        incY = 1;          
                    } else if (exit.getName().equals("east")){
                        incX = 1;
                    } else if (exit.getName().equals("west")){
                        incX = -1;         
                    }
                    
                    nextRoomId = exit.getNextRoom();

                    // if not visited, assign new coords
                    if (!visited.contains(nextRoomId)){
                        queue.add(nextRoomId);
                        coordMappingX.put(nextRoomId, x + incX);
                        coordMappingY.put(nextRoomId, y + incY);

                        if (x + incX > highestNumX){
                            highestNumX = x + incX;
                        } else if (x + incX < lowestNumX){
                            lowestNumX = x + incX;
                        }

                        if (y + incY > highestNumY){
                            highestNumY = y + incY;
                        } else if (y + incY < lowestNumY){
                            lowestNumY = y + incY;
                        }
                    } else {
                        // already visited so handles comflict if room are connected but are more tham one index apart
                        if (incX == 1){
                            coordMappingX.replace(nextRoomId, Math.max(x + incX, coordMappingX.get(nextRoomId)));
                        } else if (incX == -1){
                            coordMappingX.replace(nextRoomId, Math.min(x + incX, coordMappingX.get(nextRoomId)));
                        } else if (incY == 1){
                            coordMappingY.replace(nextRoomId, Math.max(y + incY, coordMappingY.get(nextRoomId)));
                        } else if (incY == -1){
                            coordMappingY.replace(nextRoomId, Math.min(y + incY, coordMappingY.get(nextRoomId)));
                        }
                    }
                    visited.add(nextRoomId);
                }
            }

            // makes all coords positive so maps to valid idx by removing the lowest negative number
            for (String id: visited){
                coordMappingX.replace(id, coordMappingX.get(id) - lowestNumX);
                coordMappingY.replace(id, coordMappingY.get(id) - lowestNumY);
            }

            // creates a map arr dynamically generated to the max row and col number
            mapArr = new char[highestNumY - lowestNumY + 1][highestNumX - lowestNumX + 1];
            for (y = 0; y < mapArr.length; y++){
                for (x = 0; x < mapArr[0].length; x++){
                    mapArr[y][x] = '.';
                }
            }
            // sets first room to have the players current position
            String currentRoomId = rooms.get(currentRoomIdx).getId();
            mapArr[coordMappingY.get(currentRoomId)][coordMappingX.get(currentRoomId)] = '@';
        }
    }

    // displayes map array
    public String display(){
        String displayString = "";

        if (mapArr != null){
            for (int y = 0; y < mapArr.length; y++){
                for (int x = 0; x < mapArr[0].length; x++){
                    displayString += mapArr[y][x] + "  ";
                }
                displayString += "\n\n";
            }  
            return displayString;
        } 
        return "";
    }
    
    /**
     * Returns a string representation of the map, including all rooms.
     *
     * @return a string describing the map and its rooms
     */
    @Override
    public String toString() {
        StringBuilder out = new StringBuilder("Map:\n");
        for (Room r : this.rooms) {
            out.append(r.toString()).append("\n");
        }
        return out.toString();
    }
}

